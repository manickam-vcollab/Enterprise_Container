import { StdView, Viewer } from './Viewer';
import { EventDispatcher } from './EventDispatcher';
import { viewerEvents, globalEvents } from './Events';
import { mat4 } from 'gl-matrix';
import { Color, PlaneId } from './Section';
import { CameraType, IProbeData } from './rendererTypes';
import { BackgroundType, InteractionMode } from './AppContants';
import { Label3DType } from './rendererTypes';
import { IHotspotParams } from './CAEResults/types';
declare class ViewerManager {
    private viewerMap;
    private defaultViewerID;
    private eventDispacther;
    constructor();
    getVersion(): string;
    getRenderVersion(viewerUUID: any): string;
    createViewer(_containerID: any, disableMouseEvents?: boolean): string;
    getDefaultViewerID(): any;
    getEventsList(): {
        viewerEvents: typeof viewerEvents;
        globalEvents: typeof globalEvents;
    };
    getEventDispatcher(): EventDispatcher;
    deleteViewer(viewerUUID: any): string;
    loadModel(api: string, url: string, viewerUUID: any): Promise<unknown>;
    getModelInfo(viewerUUID: any): "Invalid viewer ID" | import("./Model").IModelInfo[];
    getSceneBoundingBox(onlyVisible: boolean, viewerUUID: any): "Invalid viewer ID" | import("../plugins/Core/WebGLUtilities").BoundingBox;
    showModel(viewerUUID: any): Promise<unknown>;
    getViewer(viewerUUID: any): Viewer;
    setExternalLogger(externalLogger: any): void;
    setInterationMode(mode: InteractionMode, viewerUUID: any): void;
    setBackground(viewerUUID: any, type: BackgroundType, data: Color | any): void;
    getViewerSize(viewerUUID: any): [number, number];
    getCameraStdViews(viewerUUID: any): StdView[];
    getCameraInfo(camType: any, viewerUUID: any): any;
    setCameraInfo(camData: any, viewerUUID: any): void;
    setCameraProjection(camType: CameraType, viewerUUID: any): void;
    setMouseInputMapping(json: Object, viewerUUID: any): boolean;
    getMouseInputData(viewerUUID: any): {
        controls: any[];
        actions: any[];
    } | null;
    getSystemMouseMappings(viewerUUID: any): any[];
    getProductTree(viewerUUID: any): any;
    setSelectedParts(selectedParts: any[], viewerUUID: any): any;
    setPartsVisibility(selectedParts: string[], visibility: boolean, viewerUUID: any): Promise<string>;
    invertPartsVisibility(viewerUUID: any): Promise<string>;
    getDisplayModes(selectedNodes: any[], viewerUUID: any): Promise<import("./Model/DisplayTypes").IDisplayMode[]>;
    setDisplayMode(displayModeId: string, selectedNodes: any[], viewerUUID: any): Promise<string>;
    getSearchHints(viewerUUID: any): Promise<any[]>;
    setHighlightedNodes(selectedNodes: any[], toHighlight: boolean, viewerUUID: any): string;
    isCAEResultAvailable(viewerUUID: any): boolean;
    getDisplayResult(viewerUUID: any): import("./CAEResults/types").ICAEResult;
    getResults(viewerUUID: any): void;
    getSteps(selectedResultIndex: number, viewerUUID: any): void;
    getDerivedTypes(selectedResultIndex: number, viewerUUID: any): any;
    applyResult(resultId: string, stepId: string, derivedTypeId: string, viewerUUID: any): Promise<unknown>;
    setValueMinMax(minMax: [number, number], viewerUUID: any): void;
    getCurrentResultMinMAX(viewerUUID: any): any;
    applyMaterialColor(nodeIndexList: number[], viewerUUID: any): boolean;
    setLegendData(paletteType: number, colors: number[][], viewerUUID: any, noResultColor?: [number, number, number, number]): boolean;
    setNoResultColor(noResultColor: [number, number, number, number], viewerUUID: any): boolean;
    setAboveMaxColor(aboveMaxColor: [number, number, number, number], viewerUUID: any): boolean;
    setBelowMinColor(belowMinColor: [number, number, number, number], viewerUUID: any): boolean;
    getLegendData(viewerUUID: any): any;
    getDeformationValues(resultIndex: string, stepIndex: string, derivedTypeIndex: string, viewerUUID: any): Promise<unknown>;
    probeFromNodes(pointerData: {
        xyFromTop: number[];
        width: number;
        height: number;
    }, viewerUUID: any): import("../plugins/Picker").IProbeData | "Invalid viewer id";
    add3DLabel(uid: string, hitPoint: any[], type: Label3DType, probeData: IProbeData, viewerUUID: any): void;
    addMeasurementLabel(id: string, hitPoint: any[], type: Label3DType, probeData: IProbeData, viewerUUID: any): void;
    showHideLabelVisibility(id: string, flag: boolean, viewerUUID: any): void;
    add3dLabelforNodeId(uid: string, type: Label3DType, nodeIds: Array<number>, modelIndex: number, viewerUUID: any): boolean;
    getHotspotData(hotspotParams: IHotspotParams, variableId: string, stepId: string, derivedTypeId: string, viewerUUID: any): Promise<Uint32Array>;
    add3dLabelforNodeIndex(id: string, type: Label3DType, nodeindex: number, modelIndex: number, viewerUUID: any): string;
    add3dLabelforNodeIndexes(uid: string, type: Label3DType, nodeindexes: Array<number>, modelIndex: number, viewerUUID: any): Array<string>;
    addHotspot3dLabel(id: string, type: Label3DType, modelIndex: number, hotspotParams: IHotspotParams, variableId: string, stepId: string, derivedTypeId: string, viewerUUID: any): Promise<Array<string>>;
    delete3DLabel(uid: string, viewerUUID: any): boolean;
    get3DLabelCanvasPos(uid: string, viewerUUID: any): number[] | null;
    getLabel3DInfo(id: string, viewerUUID: any): unknown | null;
    getSectionGUIData(viewerUUID: any): any;
    setActiveSectionPlane(planeId: PlaneId, viewerUUID: any): string;
    setSectionPlaneEquation(planeId: PlaneId, transform: mat4, initTransform?: mat4, viewerUUID?: any): string;
    getSectionPlaneEquation(planeId: PlaneId, viewerUUID: any): "Invalid viewer id" | {
        transform: mat4;
        initTransform: mat4;
    };
    addSectionPlane(planeId: PlaneId, transform: mat4, color: Color, viewerUUID: any): string;
    deleteSectionPlane(planeId: PlaneId, viewerUUID: any): string;
    setSectionPlaneGUIData(planeId: PlaneId, selectedPlaneOptions: any, viewerUUID: any): string;
    enablePickAndMove(toEnable: boolean, viewerUUID: any): string;
    resetPickAndMove(viewerUUID: any): string;
    getPartPickandMoveMatrix(nodeId: string, viewerUUID: any): Float32Array | number[];
    setPartPickandMoveMatrix(nodeIds: string[], mat4: number[], viewerUUID: any): void;
    fitView(selectedNodes: any[], viewerUUID: any): any;
    captureScreen(viewerUUID: any): any;
    startAnimation(viewerUUID: any): boolean;
    stopAnimation(viewerUUID: any): boolean;
    pauseAnimation(viewerUUID: any): boolean;
    setAnimationData(type: any, numberOfFrames: number, delay: number, viewerUUID: any): boolean;
    changeAnimationFrameDelay(delay: number, viewerUUID: any): boolean;
    moveForwardAnimationFrame(viewerUUID: any): boolean;
    moveBackwardAnimationFrame(viewerUUID: any): boolean;
    moveToSpecificAnimationFrame(frameNumber: number, viewerUUID: any): boolean;
    setAnimationScaleFactor(scalefactor: [number, number, number], viewerUUID: any): boolean;
    zoomOut(scale: number, viewerUUID: any): void;
    zoomIn(scale: number, viewerUUID: any): void;
    pointZoomIn(posX: number, posY: number, factor: number, viewerUUID: any): void;
    pointZoomOut(posX: number, posY: number, factor: number, viewerUUID: any): void;
    onMouseRotation(newX: number, newY: number, lastX: number, lastY: number, viewerUUID: any): void;
    onMousePanRotation(newMouseX: number, newMouseY: number, lastMouseX: number, lastMouseY: number, viewerUUID: any): void;
    panRotateCamera(deltaX: number, deltaY: number, viewerUUID: any): void;
    rotateCamera(angleInRadian: number, axisInCameraCoord: [number, number, number], viewerUUID: any): void;
    zoomOutCamera(scale: number, viewerUUID: any): void;
    zoomInCamera(scale: number, viewerUUID: any): void;
    handleGUIEvents(eventType: any, event: any, viewerUUID: any): void;
    translatePart(newMouseX: number, newMouseY: number, lastMouseX: number, lastMouseY: number, viewerUUID: any): void;
    rotatePartCamera(angleInRadian: number, axisInCameraCoord: [number, number, number], viewerUUID: any): void;
    translateZ(scale: number, viewerUUID: any): void;
}
export { InteractionMode, EventDispatcher, viewerEvents, globalEvents, IHotspotParams, };
declare const _default: ViewerManager;
export default _default;
